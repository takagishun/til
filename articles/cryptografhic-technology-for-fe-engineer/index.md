# TLSで学ぶ暗号技術

## TLSとは

インターネットの仕組みの根幹であるTCP/IPプロトコルではセキュリティが考慮されていません。HTTP通信もそのプロトコル上で行われるので安全ではありません。安全ではない基盤の中でセキュアな通信を実現するために生まれたのがTransport
Layer Security (以下 TLS)というプロトコルです。

TLSはネットワーク階層で見るとアプリケーション層とセッション層の間に位置します。データ送信時には上層から受け取った平文を暗号化処置をして下層に転送、逆にデータ受信時には下層から暗号データを受け取り復号して上層(アプリケーション層)
に渡すわけです。ただセキュアな通信ためには様々な仕組みが必要であり、それを一つずつ理解していきたいと思います。

TODO: 図

<table>
<tr>
<th>階層名</th>
<th>説明</th>
<th>プロトコル</th>
</tr>
<tr>
<td>アプリケーション層</td>
<td>アプリケーションデータを扱う</td>
<td>HTTP</td>
</tr>
<tr>
<td>プレゼンテーション層</td>
<td>データの表現、変換、暗号化を扱う</td>
<td>SSL/TLS</td>
</tr>
<tr>
<td>セッション層</td>
<td>複数のコネクションを管理</td>
<td>-</td>
</tr>
<tr>
<td>トランスポート層</td>
<td>データ通信の制御</td>
<td>TCP</td>
</tr>
<tr>
<td>ネットワーク層</td>
<td>インターネットワークでの通信</td>
<td>IP</td>
</tr>
<tr>
<td>データリンク層</td>
<td>ローカルなデータリンクにおける通信(LAN)</td>
<td>Ethernet</td>
</tr>
<tr>
<td>物理層</td>
<td>物理的なデータのやり取り(ケーブル)</td>
<td>CAT5</td>
</tr>
</table>


## 情報セキュリティーと暗号技術

セキュアな通信を実現するのがTLSですが、そもそもセキュリティとはなんでしょうか?    
日本産業規格（JIS）では以下のように定義されています。
> 情報セキュリティとは、情報の機密性、安全性、及び可用性を維持すること。さらに真正性、責任追跡性、否認防止、信頼性などの特性を維持することを含めることもある。(※JIS Q 27000より)

TLSでは、情報セキュリティの中でも機密性、安全性、真正性を満たすために設計されてます。
そして主にこの3つの性質を満たすために暗号技術が使われるのです。


<table>
<tr>
<td>機密性</td>
<td>認可した人以外はアクセスできない事。秘匿性。</td>
</tr>
<tr>
<td>安全性</td>
<td>データは改竄や削除がされていない事。</td>
</tr>
<tr>
<td>真正性</td>
<td>その人が本物であること。</td>
</tr>
</table>

## 安全な文通

より具体的にセキュアな通信についてどのようなものか、イメージしやすいように、秘密の文通について考えてみます。

アリスとボブは文通をしているのですが、内容を誰にもわからないように文章を暗号化やりとりしたいと考えました。  
暗号化の方法はいくつかありますが、一つ目の方法はシフト暗号と言って文字を数文字シフトさせ暗号化する方法で、例えば3つシフトする場合は「あ」は「え」に、「い」は「お」に置き換えて暗号文を作成します。もう一つの方法は換字式暗号といい、それぞれの文字に対応する換字表を使い「あ」に対応する文字は「さ」、「い」に対応する文字は「す」というでたらめに変換して暗号文を作る方法です。 暗号文を復号する場合は同じ分だけシフトしたり、同じ換字表を使い平文に戻します。  
それぞれの方法の極秘情報はシフト方式の場合は何個ずらすかという情報であり、換字式の場合は換字表です。アリスとボブは暗号方式についてや極秘情報の共有方法について暗号化してない文通で相談し、暗号方式は「換字式」にすることにして、極秘情報はばれたりすり替えられたりすると大変なので受け渡しは郵送ではなく直接渡すことにしました。  
極秘情報を共有できたことで晴れて二人だけしか知らない暗号文で文通ができます。
しかし、まだ問題があります。暗号文自体が誰かに改竄されると復号したときに違う文章になってしまうので, お互いが書いた暗号文ということしっかしわかるようにしたいと思いました。そのためワープロではなく手書きにし、サインを添えることで、筆跡で判断できるようにしました。

無理やり感がある例でしたが、強度はおいといて一応機密性、安全性、真正性を考慮した設計になっています。
暗号化手順をまとめると次のようになります

- 暗号化方式の合意
- 暗号化/復号に使う極秘情報の共有方法の合意
- 極秘情報の共有
- 文章を暗号化して郵送
- 受け取った手紙の送り主が正しいことを検証
- 復号して読む

TLSで通信する場合でもざっくりとした手順は似ています。 

## TLSのプロトコル

TLSのプロトコルを理解しながら、オンラインでのセキュアな通信がどのように確立するのか見ていきたいと思います

※TLSバージョンの最新である1.3に基づいて説明します

[RFC8446 section-5](https://datatracker.ietf.org/doc/html/rfc8446#section-5)

TLSは次の2つの主要なプロトコルから成り立ちます。
- 通信相手の認証や通信相手と暗号化方式の合意、極秘情報(以後、共有鍵)の共有を担当するハンドシェイクプロトコル
- データを管理可能なブロックに断片化したりそのブロックを暗号化して保護したりする役割のレコードプロトコル

TLSはレコード(サイズは16384バイト)と呼ばれる単位でデータを扱い、各レコードは次のような多層構造になっています。  
[RFC8446 section-5.1](https://datatracker.ietf.org/doc/html/rfc8446#section-5.1)
- コンテンツタイプ
  - サブプロトコルの「ハンドシェイク」、「アプリケーションデータ」などを指定します。先ほど説明した通り認証、暗号化方式の合意、共有鍵共有をする一連のやりとりでは「ハンドシェイク」と指定し、実際にアプリケーション層のデータを暗号化してやりとりをする際には「アプリケーションデータ」などを指定します。
- レコード長
- メッセージデータ
  - サブプロトコルをカプセル化します。例えばコンテンツタイプが「ハンドシェイク」の場合は、このレコード層のメッセージデータのなかに、さらにハンドシェイクタイプ・メッセージ長・メッセージといった構造をもちます。([RFC8446 section-4](https://datatracker.ietf.org/doc/html/rfc8446#section-4))

## ハンドシェイクプロトコル

ハンドシェイクプロトコルは認証・暗号化方式・共有鍵共有のためのデータ(セキュリティパラメータ)をネゴシエートするために使用され、クライアント/サーバー間で一連のやりとりが行われます。
ハンドシェイクには、サーバー認証だけのフルハンドシェイクや、クライアント認証も行うフルハンドシェイク、セッション再開時に行うもの、様々がありますが、今回はサーバー認証のみのフルハンドシェイクについて説明します。

ハンドシェイクのメッセージは３つのフィールドから構成されます。
- ハンドシェイクタイプ
  - ClientHello、ServerHelloなどハンドシェイクメッセージの種類が入ります。
- メッセージ長
- ハンドシェイクメッセージ
  - ハンドシェイクタイプ毎に必要なフィールドが異なります。

TODO: 図

## ClientHelloメッセージ

[RFC8446 section-4.1.2](https://datatracker.ietf.org/doc/html/rfc8446#section-4.1.2)

クライアントが最初にサーバーに接続するとき、クライアントが望む暗号方式や秘密鍵共有方式を提案(同時に秘密鍵共有に必要なデータも送っています)するためにClientHelloメッセージを最初のTLSメッセージとして送信する必要があります。
このメッセージに必要なフィールドはRandom・CipherSuite・Extensionsの3つです。 実際のデータには他にもフィールドがありますが、後方互換性などのためでありTLS1.3では利用しないことになっています。例えばversionフィールドに0x0303（TLS 1.2のバージョン番号）とありますが、本当のバージョンはExtensionフィールドのsupported_versionsに記載されています。
- Randomフィールド
  - 乱数生成器で作成する32バイトの値でハンドシェイクメッセージが一意になります。
- CipherSuiteフィールド
  - クライアントが対応可能な暗号スイートを優先度順に提示します
  - 暗号スイートは、レコード保護アルゴリズムとHKDFで使用されるハッシュで構成され「TLS_暗号アルゴリズム名_秘密鍵の長さ_暗号化モード名_ハッシュ名」という形で表現されます
  - TLS1.3で使える暗号スイートは5つのみで、どれもAEAD(認証付き暗号)です。
    - TLS_AES_128_GCM_SHA256
    - TLS_AES_256_GCM_SHA384
    - TLS_CHACHA20_POLY1305_SHA256
    - TLS_AES_128_CCM_SHA256
    - TLS_AES_128_CCM_8_SHA256
- Extensionsフィールド [RFC8446 section-4.2](https://datatracker.ietf.org/doc/html/rfc8446#section-4.2)

  - 付加的なデータを運ぶ拡張が、任意の数だけ含まれます。
  - Extension: supported_groups
    - クライアントがサポートする鍵交換アルゴリズムを順番に並べます。TLS1.3では前方秘密(PFS)があるDHEおよびECDHEのみ使用可能なのでRSAや静的DHは使えなません。
  - Extension: key_share
    - 鍵交換アルゴリズム(group)とそれに必要な情報(Key Exchange)をセットで任意数提供します。
  - supported_versions
    - サポートされているTLSバージョンのリストが優先順に含まれており、最も優先されるバージョンが最初になります。

## ServerHelloメッセージ

[RFC8446 section-4.1.3](https://datatracker.ietf.org/doc/html/rfc8446#section-4.1.3)


ClientからのClientHelloメッセージをサーバーが受け取ると暗号方式や秘密鍵共有方式を決定した上でほぼ同じ構造でServerHelloメッセージをクライアントに返します。
- Randomフィールド
  - 乱数生成器で作成する32バイトの値。
- CipherSuiteフィールド
  - クライアントから提案された暗号スイートから1つ選択する。
- Extensionsフィールド [RFC8446 section-4.2](https://datatracker.ietf.org/doc/html/rfc8446#section-4.2)
  - 付加的なデータを運ぶ拡張が、任意の数だけ含まれます。
  - Extension: key_share
    - クライアントの「supported_groups」拡張で示されいる鍵交換アルゴリズムから1つ選択し、鍵交換アルゴリズム(group)とそれに必要な情報(Key Exchange)をセットで返します。
  - supported_versions
    - サポートされているTLSバージョンのリストが優先順に含まれており、最も優先されるバージョンが最初になります。

## 鍵交換

[RFC8446 section-7](https://datatracker.ietf.org/doc/html/rfc8446#section-7)

「安全な文通」セクションでは暗号化に使用する鍵交換(極秘情報の共有)を手渡しで行っていましたので、鍵交換において機密性と安全性がありました。  
それをオンラインで実現するにはどうすれば良いでしょうか? TLSではClientHelloメッセージの拡張フィールド(supported_groupsとkey_share)とServerHelloメッセージの拡張フィールド(key_share)で鍵交換を行ますが、このやりとりはまだ暗号化されていません。鍵を直接メッセージに含めると盗聴されてしまいます。
そこで盗聴されて良い値を交換しその値からお互い計算して共通の鍵を作る方法が(EC)DHE鍵交換という仕組みです。※自分は最初そんな魔法のような方法があるのかって思ってました。 

(EC)DHE鍵交換の仕組みについて説明する前にに基となるDH鍵交換について説明します。

> #### [ディフィー・ヘルマン鍵共有  ウィキペディア（Wikipedia）](https://ja.wikipedia.org/wiki/%E3%83%87%E3%82%A3%E3%83%95%E3%82%A3%E3%83%BC%E3%83%BB%E3%83%98%E3%83%AB%E3%83%9E%E3%83%B3%E9%8D%B5%E5%85%B1%E6%9C%89)
> DH鍵交換はべき乗の次の性質を使います。
> ※慣れ親しいjavascriptで書いてみます
> ``` javascript
> const g = 2 // 公開されている値
> const n = 3 // 公開されている値
> const a = 10 // アリスだけしか知らない秘密鍵
> const b = 12 // ボブだけしか知らない秘密鍵
> const A = g ** a % n // 盗聴されても良い
> const B = g ** b % n // 盗聴されても良い
> const X = A ** b % n // 共有鍵(秘密鍵)
> const Y = B ** a % n // 共有鍵(秘密鍵)
> console.log(X === Y) // true
> ```
> 
> この性質を利用したのがDH鍵共有の方法です。
> 1. 自分しか知らない値としてアリスがaをボブがbを持ち、gとnは誰でも知って良い値とします。
> 2. アリスはgのa乗してnで割った余りAをボブに渡します。
> 3. ボブはgのb乗してnで割った余りBをアリスに渡します。
> 4. アリスはBをa乗してnで割った余りを求めXとします
> 5. ボブはAをb乗してnで割った余りを求めYとします
> 6. X===Yになるのでこれを秘密鍵として共有します
>
> 気になるのはX,Yの安全性です。公開されて良いg,n,A,Bを通じてXとYが求められてしまうと安全ではないのですが、どうやらnが600桁以上といくつかの条件を満たすとどんなスーパーコンピューターでも計算するのが難しいと言われているそうです。
> (EC)DHEのEはEphemeralで一時的な鍵のことを示しており、お互いの秘密鍵(例でいうa,b)をハンドシェイク毎に違うものを使用します。これによってPFS(前方秘匿性)を持つことができます。
>
> ここまで説明しておいてあれですが、DHEよりECDHEの方が処理が高速で、ECDHEを使用することが推薦されているようです
> ECDHEとは楕円曲線を用いた鍵共有方法です。楕円曲線は難しくて自分は説明できないのですが、公開して良い値から共有鍵をお互い計算できる点ではDHEと同じです。

ここまでで鍵を共有で秘匿性はありますが、安全性はありません。鍵交換した相手が本物かどうか確かめる必要があります。 TLSでは後述のCertificateメッセージやCertificateVerifyメッセージでそれを実現します。

## 鍵導出

ここまでで(EC)DHE鍵交換を通して鍵を共有できましたが、TLSではこの鍵をそのまま暗号化に利用しません。    
HKDFという技術を通してハンドシェイク毎に変わるより安全な鍵を複数作成し用途に応じてそれぞれを利用します。

> #### メッセージ認証コード（MAC: Message Authentication Code） 【 [RFC2104](https://datatracker.ietf.org/doc/html/rfc2104) 】
>
> MACとはメッセージに認証機能を持たせる技術です。MACを利用することで受信したメッセージが改竄されてないことやなりすましがないことを確認できます。   
> MACは次の手順によって実現されます。
> 1. ボブは、アリスと共有した秘密鍵と送信したいメッセージをinputに固定ビット長(MAC値)を計算します。
> 2. ボブはMAC値とメッセージをアリスに送信します。
> 3. アリスは受信したメッセージと秘密鍵からMAC値を計算します。
> 4. アリスは受信したMAC値と、計算したMAC値が同じか検証します。
>
> MACの計算では、メッセージが1ビットでも変更されると異なるMAC値になるため改竄ができません。また、共有鍵を持っていない人はメッセージの正しいMAC値を計算できないのでなりすましができません。
>
> MAC値の計算にSHA-256のようなハッシュ関数を利用する方法を **HMAC** といいます。

> #### HKDF（HMAC-based key derivation function）【 [RFC5869](https://datatracker.ietf.org/doc/html/rfc5869) 】
>
> HKDFとはHMACをベースとしていくつかの入力から1つまたは複数の暗号的に強い秘密鍵を作成する技術です。
> 強力な疑似乱数鍵(PRK)を一つ作成する抽出工程と、PRKから複数の追加疑似乱数鍵(OKM)を作成する拡張工程を経て鍵を作成します。
>
> 抽出：
> ソルト(あるいは空文字)とメッセージ(鍵材料)を引数に持ったHKDF-Extractという関数で行われ、この２つの引数のHMACを計算してPRKを求めます。
> 
> 拡張：
> 抽出工程で求めたPRK、アプリケーション固有の情報(context)、出力長を引数に持ったHKDF-Expandという関数で行われ、内部でHMACを使用して鍵(OKM)を求めます。contextを変更することで任意数の鍵を作成できます。
> 



HKDF内のHMACで使われるハッシュ関数は暗号スイートで指定したハッシュアルゴリズムを利用します。  
「TLS_AES_128_GCM_SHA256」の場合は、SHA256がハッシュアルゴリズムです。

TLSではHKDFの拡張工程であるHKDF-Expand関数をラップしたDerive-Secret関数を利用しており、HKDF-Expand関数に引数であるcontextにトランスクリプトハッシュ(後述)を含めるような仕組みになっています。

```
struct {
  uint16 length = Length;
  opaque label<7..255> = "tls13 " + Label;
  opaque context<0..255> = Context;
} HkdfLabel;
HKDF-Expand-Label(PRK, Label, Context, Length) = HKDF-Expand(PRK, HkdfLabel, Length)
Derive-Secret(PRK, Label, Messages) = HKDF-Expand-Label(PRK, Label, Transcript-Hash(Messages), Hash.length)
```

TLSのHKDFを利用した鍵導入プロセスとそこれ作成される鍵の詳細は[RFC8446 section-7.1 Key Schedule](https://datatracker.ietf.org/doc/html/rfc8446#section-7.1)
をご参照ください

## 暗号化

ここまででメッセージを暗号化できる準備できました。

- 暗号化方式
  - ClientHelloとServerHelloで合意した暗号スイートに記載
  - TLS_AES_128_GCM_SHA256の場合はAES_128_GCMの部分
- 暗号に使用する秘密鍵
  - (EC)DHE鍵交換で共有したものを元にHKDFで計算されたもの
  - 暗号化するメッセージによって使う秘密鍵が違う

> #### 認証付き暗号 AES_128_GCM 【 [RFC5116](https://datatracker.ietf.org/doc/html/rfc5116) 】
> メッセージのやりとりでは機密性と安全性の両方を満たす必要があります。つまり許可されている人だけがメッセージの内容を読めるようにし、かつメッセージの変更や偽造がされていないことを保証する必要があります。
> これまで説明した通り前者は暗号化で、後者はMACで実現できますが、暗号とMACの処理順序や組み合わせ、方式選択によってはセキュリティに問題が出てきてしまうため、それらを統一したアルゴリズムであるAEADが考えられました。
> またパフォーマンスの観点でもメリットがあります。
> AEADのAES_GCMとは、AES Galois/Counter Modeの略であり、暗号化にAESのcounter mode、認証部分にガロア体を使用します。

## EncryptedExtensions

鍵交換や暗号化を確率するための拡張以外のものを送信します。

## 認証

ここまでで共通鍵が用意でき暗号化はできるようになりました。しかしそもそも鍵交換時に改竄やなりすましが行われていたとしたら意味がないので、鍵共有した相手が本物かどうかを認証する必要があります。
Certificateメッセージ、CertificateVerifyメッセージ、Finishedメッセージによって認証します。

## Certificateメッセージ

暗号化できるようになりましたが、そもそも鍵交換をしている相手が本当に想定している相手かどうか認証するために、Certificateメッセージでサーバー証明書とそのチェーンの中間証明書を送信します。受け取ったクライアントはOSに組み込まれているルートCA証明書を使って、それぞれの証明書の正当性を検証します。
この証明書を使った認証や検証の仕組みを公開鍵基盤といいます。 証明書の署名に使用するアルゴリズムはClientHello/ServerHelloの拡張のsignature_algorithmsに記載されるものです。

証明書を受信した場合の検証手順は次のRFCに記載されています  
https://datatracker.ietf.org/doc/html/rfc5280

## CertificateVerifyメッセージ
CertificateVerifyメッセージはサーバー証明書に対応する秘密鍵を保持していることの証明をするためのメッセージです。また今までのハンドシェイクメッセージの整合性も保証します。
このメッセージにはデジタル署名とその署名アルゴリズムが含まれ暗号化されて送られます。
このデジタル署名の内容は次の通りです
- デジタル署名対象コンテンツ
  - トランスクリプトハッシュ + いくつかのデータ
    - トランスクリプトハッシュとは、これまでのハンドシェイクメッセージとそのヘッダーを連結して合意した暗号スイートに含まれるハッシュアルゴリズムでハッシュ化したもの
- 署名に使用される秘密鍵
  - Certificateメッセージで送信したサーバー証明書に対応する秘密鍵
- 署名アルゴリズム
  - ClientHelloメッセージの拡張フィールドのsignature_algorithmsに記載されたものから選択

トランスクリプトハッシュをサーバー証明書秘密鍵で署名し、サーバー証明書の公開鍵で検証することで、ハンドシェイクが改竄されていたことを検知できます
ハンドシェイクメッセージが1ビットでも違えばトランスクリプトハッシュも異なるからです。

## デジタル署名の検証

CertificateVerifyメッセージを受け取ったクライアントは、デジタル署名の正当性をサーバー証明書の公開鍵で検証する。 検証方法は次の通りです。

1. CertificateVerifyメッセージのデジタル署名をCertificateメッセージで受け取ったサーバー証明書の公開鍵を使ってデジタル署名対象コンテンツを取り出す
2. クライアントでも同じ方法でデジタル署名対象コンテンツを求める
3. 1と2が同じか検証する

## Server Finishedメッセージ

- ハンドシェイクの一連のメッセージの完全性を検証
- verify_dataはトランスクリプトハッシュ(Client Hello~CertificateVerify)と鍵スケジュール(HKDF)
  で生成したbaseKeyのserver_handshake_traffic_secretをfinished_keyにしてHMACした値
- 暗号化されて送られる
- 受け取ったら検証する

## Client Finishedメッセージ

- 同様にハンドシェイクの一連のメッセージの完全性を検証
- verify_dataはトランスクリプトハッシュ(Client Hello~CertificateVerify)と鍵スケジュール(HKDF)
  で生成したbaseKeyのclient_handshake_traffic_secretをfinished_keyにしてHMACしたMAC値(https://datatracker.ietf.org/doc/html/rfc8446#section-4.4)
- 暗号化されて送られる
- 受け取ったら検証する

```
struct {
opaque verify_data[Hash.length];
} Finished;
```

```
verify_data = HMAC(finished_key,
Transcript-Hash(Handshake Context, Certificate*, CertificateVerify*))
```

## まとめ

TODO

# RFC

TLS1.2: https://datatracker.ietf.org/doc/html/rfc5246  
TLS1.3: https://datatracker.ietf.org/doc/html/rfc8446  
DHEパラメータ: https://datatracker.ietf.org/doc/html/rfc7919  
暗号と認証の仕組みがわかる教科書   
プロフェッショナルSSL/TLS   
暗号技術入門  

# 参考
https://jovi0608.hatenablog.com/entry/2018/05/09/213703
https://milestone-of-se.nesuke.com/nw-basic/tls/diffie-hellman-summary/







