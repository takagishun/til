# TLSで学ぶ暗号技術

## TLSとは

インターネットの仕組みの根幹であるTCP/IPプロトコルではセキュリティが考慮されていません。HTTP通信もそのプロトコル上で行われるので安全ではありません。安全ではない基盤の中でセキュアな通信を実現するために生まれたのがTransport
Layer Security (以下 TLS)というプロトコルです。

TLSはネットワーク階層で見るとアプリケーション層とセッション層の間に位置します。データ送信時には上層から受け取った平文を暗号化処置をして下層に転送、逆にデータ受信時には下層から暗号データを受け取り復号して上層(アプリケーション層)
に渡すわけです。ただセキュアな通信ためには様々な仕組みが必要であり、それを一つずつ理解していきたいと思います。

TODO: 図

<table>
<tr>
<th>階層名</th>
<th>説明</th>
<th>プロトコル</th>
</tr>
<tr>
<td>アプリケーション層</td>
<td>アプリケーションデータを扱う</td>
<td>HTTP</td>
</tr>
<tr>
<td>プレゼンテーション層</td>
<td>データの表現、変換、暗号化を扱う</td>
<td>SSL/TLS</td>
</tr>
<tr>
<td>セッション層</td>
<td>複数のコネクションを管理</td>
<td>-</td>
</tr>
<tr>
<td>トランスポート層</td>
<td>データ通信の制御</td>
<td>TCP</td>
</tr>
<tr>
<td>ネットワーク層</td>
<td>インターネットワークでの通信</td>
<td>IP</td>
</tr>
<tr>
<td>データリンク層</td>
<td>ローカルなデータリンクにおける通信(LAN)</td>
<td>Ethernet</td>
</tr>
<tr>
<td>物理層</td>
<td>物理的なデータのやり取り(ケーブル)</td>
<td>CAT5</td>
</tr>
</table>


## 情報セキュリティーと暗号技術

セキュアな通信を実現するのがTLSですが、そもそもセキュリティとはなんでしょうか?    
日本産業規格（JIS）では以下のように定義されています。
> 情報セキュリティとは、情報の機密性、安全性、及び可用性を維持すること。さらに真正性、責任追跡性、否認防止、信頼性などの特性を維持することを含めることもある。(※JIS Q 27000より)

TLSでは、情報セキュリティの中でも機密性、安全性、真正性を満たすために設計されてます。
そして主にこの3つの性質を満たすために暗号技術が使われるのです。


<table>
<tr>
<td>機密性</td>
<td>認可した人以外はアクセスできない事。秘匿性。</td>
</tr>
<tr>
<td>安全性</td>
<td>データは改竄や削除がされていない事。</td>
</tr>
<tr>
<td>真正性</td>
<td>その人が本物であること。</td>
</tr>
</table>

## 安全な文通

より具体的にセキュアな通信についてどのようなものか、イメージしやすいように、秘密の文通について考えてみます。

アリスとボブは文通をしているのですが、内容を誰にもわからないように文章を暗号化やりとりしたいと考えました。  
暗号化の方法はいくつかありますが、一つ目の方法はシフト暗号と言って文字を数文字シフトさせ暗号化する方法で、例えば3つシフトする場合は「あ」は「え」に、「い」は「お」に置き換えて暗号文を作成します。もう一つの方法は換字式暗号といい、それぞれの文字に対応する換字表を使い「あ」に対応する文字は「さ」、「い」に対応する文字は「す」というでたらめに変換して暗号文を作る方法です。 暗号文を復号する場合は同じ分だけシフトしたり、同じ換字表を使い平文に戻します。  
それぞれの方法の極秘情報はシフト方式の場合は何個ずらすかという情報であり、換字式の場合は換字表です。アリスとボブは暗号方式についてや極秘情報の共有方法について暗号化してない文通で相談し、暗号方式は「換字式」にすることにして、極秘情報はばれたりすり替えられたりすると大変なので受け渡しは郵送ではなく直接渡すことにしました。  
極秘情報を共有できたことで晴れて二人だけしか知らない暗号文で文通ができます。
しかし、まだ問題があります。暗号文自体が誰かに改竄されると復号したときに違う文章になってしまうので, お互いが書いた暗号文ということしっかしわかるようにしたいと思いました。そのためワープロではなく手書きにし、サインを添えることで、筆跡で判断できるようにしました。

無理やり感がある例でしたが、強度はおいといて一応機密性、安全性、真正性を考慮した設計になっています。
暗号化手順をまとめると次のようになります

- 暗号化方式の合意
- 暗号化/復号に使う極秘情報の共有方法の合意
- 極秘情報の共有
- 文章を暗号化して郵送
- 受け取った手紙の送り主が正しいことを検証
- 復号して読む

TLSで通信する場合でもざっくりとした手順は似ています。 

## TLSのプロトコル

TLSのプロトコルを理解しながら、オンラインでのセキュアな通信がどのように確立するのか見ていきたいと思います

※TLSバージョンの最新である1.3に基づいて説明します

[RFC8446 section-5](https://datatracker.ietf.org/doc/html/rfc8446#section-5)

TLSは次の2つの主要なプロトコルから成り立ちます。
- 通信相手の認証や通信相手と暗号化方式の合意、極秘情報(以後、共有鍵)の共有を担当するハンドシェイクプロトコル
- データを管理可能なブロックに断片化したりそのブロックを暗号化して保護したりする役割のレコードプロトコル

TLSはレコード(サイズは16384バイト)と呼ばれる単位でデータを扱い、各レコードは次のような多層構造になっています。  
[RFC8446 section-5.1](https://datatracker.ietf.org/doc/html/rfc8446#section-5.1)
- コンテンツタイプ
  - サブプロトコルの「ハンドシェイク」、「アプリケーションデータ」などを指定します。先ほど説明した通り認証、暗号化方式の合意、共有鍵共有をする一連のやりとりでは「ハンドシェイク」と指定し、実際にアプリケーション層のデータを暗号化してやりとりをする際には「アプリケーションデータ」などを指定します。
- レコード長
- メッセージデータ
  - サブプロトコルをカプセル化します。例えばコンテンツタイプが「ハンドシェイク」の場合は、このレコード層のメッセージデータのなかに、さらにハンドシェイクタイプ・メッセージ長・メッセージといった構造をもちます。([RFC8446 section-4](https://datatracker.ietf.org/doc/html/rfc8446#section-4))

## ハンドシェイクプロトコル

ハンドシェイクプロトコルは認証・暗号化方式・共有鍵共有のためのデータ(セキュリティパラメータ)をネゴシエートするために使用され、クライアント/サーバー間で一連のやりとりが行われます。
ハンドシェイクには、サーバー認証だけのフルハンドシェイクや、クライアント認証も行うフルハンドシェイク、セッション再開時に行うもの、様々がありますが、今回はサーバー認証のみのフルハンドシェイクについて説明します。

ハンドシェイクのメッセージは３つのフィールドから構成されます。
- ハンドシェイクタイプ
  - ClientHello、ServerHelloなどハンドシェイクメッセージの種類が入ります。
- メッセージ長
- ハンドシェイクメッセージ
  - ハンドシェイクタイプ毎に必要なフィールドが異なります。

TODO: 図

## ClientHelloメッセージ

[RFC8446 section-4.1.2](https://datatracker.ietf.org/doc/html/rfc8446#section-4.1.2)

クライアントが最初にサーバーに接続するとき、クライアントが望む暗号方式や秘密鍵共有方式を提案(同時に秘密鍵共有に必要なデータも送っています)するためにClientHelloメッセージを最初のTLSメッセージとして送信する必要があります。
このメッセージに必要なフィールドはRandom・CipherSuite・Extensionsの3つです。 実際のデータには他にもフィールドがありますが、後方互換性などのためでありTLS1.3では利用しないことになっています。例えばversionフィールドに0x0303（TLS 1.2のバージョン番号）とありますが、本当のバージョンはExtensionフィールドのsupported_versionsに記載されています。
- Randomフィールド
  - 乱数生成器で作成する32バイトの値でハンドシェイクメッセージが一意になります。
- CipherSuiteフィールド
  - クライアントが対応可能な暗号スイートを優先度順に提示します
  - 暗号スイートは、レコード保護アルゴリズムとHKDFで使用されるハッシュで構成され「TLS_暗号アルゴリズム名_秘密鍵の長さ_暗号化モード名_ハッシュ名」という形で表現されます
  - TLS1.3で使える暗号スイートは5つのみで、どれもAEAD(認証付き暗号)です。
    - TLS_AES_128_GCM_SHA256
    - TLS_AES_256_GCM_SHA384
    - TLS_CHACHA20_POLY1305_SHA256
    - TLS_AES_128_CCM_SHA256
    - TLS_AES_128_CCM_8_SHA256
- Extensionsフィールド [RFC8446 section-4.2](https://datatracker.ietf.org/doc/html/rfc8446#section-4.2)

  - 付加的なデータを運ぶ拡張が、任意の数だけ含まれます。
  - Extension: supported_groups
    - クライアントがサポートする鍵交換アルゴリズムを順番に並べます。TLS1.3では前方秘密(PFS)があるDHEおよびECDHEのみ使用可能なのでRSAや静的DHは使えなません。
  - Extension: key_share
    - 鍵交換アルゴリズム(group)とそれに必要な情報(Key Exchange)をセットで任意数提供します。
  - supported_versions
    - サポートされているTLSバージョンのリストが優先順に含まれており、最も優先されるバージョンが最初になります。

## ServerHelloメッセージ

[RFC8446 section-4.1.3](https://datatracker.ietf.org/doc/html/rfc8446#section-4.1.3)


ClientからのClientHelloメッセージをサーバーが受け取ると暗号方式や秘密鍵共有方式を決定した上でほぼ同じ構造でServerHelloメッセージをクライアントに返します。
- Randomフィールド
  - 乱数生成器で作成する32バイトの値。
- CipherSuiteフィールド
  - クライアントから提案された暗号スイートから1つ選択する。
- Extensionsフィールド [RFC8446 section-4.2](https://datatracker.ietf.org/doc/html/rfc8446#section-4.2)
  - 付加的なデータを運ぶ拡張が、任意の数だけ含まれます。
  - Extension: key_share
    - クライアントの「supported_groups」拡張で示されいる鍵交換アルゴリズムから1つ選択し、鍵交換アルゴリズム(group)とそれに必要な情報(Key Exchange)をセットで返します。
  - supported_versions
    - サポートされているTLSバージョンのリストが優先順に含まれており、最も優先されるバージョンが最初になります。

## 鍵交換と鍵の導出

[RFC8446 section-7](https://datatracker.ietf.org/doc/html/rfc8446#section-7)

「安全な文通」セクションでは暗号化に使用する鍵交換(極秘情報の共有)を手渡しで行っていましたので、鍵交換において機密性と安全性がありました。  
オンラインの通信ではどのように行われるのでしょうか? TLSではClientHelloメッセージの拡張フィールド(supported_groupsとkey_share)とServerHelloメッセージの拡張フィールド(key_share)で鍵交換を行ますが、このやりとりはまだ暗号化されていません。鍵を直接メッセージに含めると盗聴されてしまいます。
そこで盗聴されて良い値を交換しその値からお互い計算して共通の鍵を作る方法が(EC)DHE鍵交換という仕組みです。

(EC)DHE鍵交換の仕組みについて説明する前にに基となるDH鍵交換について説明します。

DH鍵交換は乗の性質を使います。

- (g^a)^b = g^ab = g^ba = (g^b)^a
- ab が大きいと g^ab が大きくなりすぎるので、予め決めた n で割った余りを考える
- A = g^a mod n, B = g^b mod n, A^b ≡ B^a (mod n)

↑ がこの関係式が鍵共有のポイント ↓ べき乗の性質を利用した鍵共有方法

1. アリスとボブで g と n を固定する。g と n は公開されても良い値
2. アリスは秘密値 a を決めて、A = g^a mod n をボブに渡す
3. ボブは秘密値 b を決めて、B = g^b mod n をアリスに渡す
4. アリスはボブからもらった B から s = B^a mod n を求める
5. ボブはアリスからもらった A から s' = A^b mod n を求める
6. s = s' = g^ab mod n になり同じ値を共有できる(共通暗号の秘密鍵)

a を決めて g^a mod n の計算は簡単だが、g と n がわかった状態でも g^a mod n となる a を求めるのは困難 <= 1 方向性関数
n が 600 桁以上の素数である条件を満たしていたら、現在に存在するどんなスーパーコンピューターでも解けないと予測されている


TODO
https://milestone-of-se.nesuke.com/nw-basic/tls/diffie-hellman-summary/  
これ読む。 DHEパラメータの仕様
https://datatracker.ietf.org/doc/html/rfc7919

- DH鍵交換とHKDF(鍵導入)でPS(前方秘匿性)が得られる

## Certificateメッセージ

- 証明書の送信
- 認証。真正性。
- 基本サーバー証明書のみ
- 暗号化されて送られる

## 証明書の検証

- OSに用意されたルートCA証明書を利用して、サーバ証明書を本物かどうか検証する
- 証明書の検証手順
  - https://datatracker.ietf.org/doc/html/rfc5280

## CertificateVerifyメッセージ

- サーバー証明書の秘密鍵を保持していることの証明をするためのメッセージ
- 暗号化されて送られる
- 署名対象コンテンツ
  - トランスクリプトハッシュ
    - 各ハンドシェイクメッセージの連結のハッシュを計算
- 署名に使用される秘密鍵
  - サーバー証明書の秘密鍵
- このメッセージを受け取ったクライアントは、サーバー証明書の公開鍵で検証する

```
struct {
    SignatureScheme algorithm;
    opaque signature<0..2^16-1>;
} CertificateVerify;
```

## Server Finishedメッセージ

- ハンドシェイクの一連のメッセージの完全性を検証
- verify_dataはトランスクリプトハッシュ(Client Hello~CertificateVerify)と鍵スケジュール(HKDF)
  で生成したbaseKeyのserver_handshake_traffic_secretをfinished_keyにしてHMACした値
- 暗号化されて送られる
- 受け取ったら検証する

## Client Finishedメッセージ

- 同様にハンドシェイクの一連のメッセージの完全性を検証
- verify_dataはトランスクリプトハッシュ(Client Hello~CertificateVerify)と鍵スケジュール(HKDF)
  で生成したbaseKeyのclient_handshake_traffic_secretをfinished_keyにしてHMACしたMAC値(https://datatracker.ietf.org/doc/html/rfc8446#section-4.4)
- 暗号化されて送られる
- 受け取ったら検証する

```
struct {
opaque verify_data[Hash.length];
} Finished;
```

```
verify_data = HMAC(finished_key,
Transcript-Hash(Handshake Context, Certificate*, CertificateVerify*))
```

## HMACについて

## 鍵スケジュール(HKDF)

## まとめ

TODO

# RFC

TLS1.2: https://datatracker.ietf.org/doc/html/rfc5246
TLS1.3: https://datatracker.ietf.org/doc/html/rfc8446
暗号と認証の仕組みがわかる教科書 プロフェッショナルSSL/TLS 暗号技術入門 【図解】ネットワーク/サーバ/セキュリティの基礎から応用まで







