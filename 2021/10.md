# 10月15日

## ReactのFormライブラリ

雑にメモ。Formライブラリ自体あまり使ったことなくて試したくなった
変遷をまとめると以下のようになる。

* 状態の管理方法: グローバルステート(redux form) => ローカルステート(formik) => ref(react-hook-form)
* controlled => Uncontrolled

### redux form
* パフォーマンスに課題あり
* 入力値を変えるアクションが発火
* 上の方でconnectしてるのでreduxツリー全体が再計算される
* v6~?からconnectが末端に実装されたが、connectの処理自体が重い
* controlled

### formik
* Formのような一時的なstateに対してグローバルステータスを使うのはあまり良くない => local stateを使う
* でもパフォーマンスが改善されてない
* (パフォーマンス面で)原則: useStateは末端で、memo化は上で => formikは逆の設計になっている
* controlled

### react-hook-form
* refを扱う必要あり
* 入力値を変更するのみだったらrefを使うので再レンダリングは一切発生しない
* ただerrorsはformStateに入っている。バケツリレーするのでそこでレンダリングされちゃう
* なのでonChangeバリデしないでonBlurでバリデやった方が良い
* useController APIは下で使うべき。inputの隣とか
* uncontrolled

# 10月14日

## File Upload
https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload  
XMLHttpRequest の upload プロパティは、アップロードの進捗を監視することができる。
Fileアップロードのプログレスバーを表示する時などに使えるっぽいので方法を調べていきたい。


# 10月13日

## reselect
https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc
> createSelector determines if the value returned by an input-selector has changed between calls using reference equality (===). Inputs to selectors created with createSelector should be immutable.

第一引数に与えられたセレクターが返す値を===で比較して、同じであれば再計算されずメモ化した値を返す。
なのでセレクターが返す値がreference型の場合は、同じ値であってもreference異なれば再計算される。

↓の例だとstateのオブジェクトの参照が違うので_selector1,_selector2どちらとも再計算され新しいオブジェクトを返す。
そのため_selector1,_selector2を引数にしているselectorも、再計算される
```js
const _selector1 = createSelector(state => state, () => ({}))
const _selector2 = createSelector(state => state, () => ({}))
const selector = createSelector([_selector1, _selector2], () => console.log('execute!'))

selector({})
selector({})
```
```
$ node index.js 
execute!
execute!
```

reactのmemo、useEffect,useMemoの第２引数とかでも同じなので、redux, react界隈のここら辺の比較ロジックは共通なんだろう。

https://github.com/reduxjs/reselect#createselectorcreatormemoize-memoizeoptions
createSelectorCreator APIを使えば、独自の等価チェック機構を持ったcreateSelectorを作成できる
```js
const {createSelectorCreator, defaultMemoize} = require("reselect");
const {isEqual} = require("lodash")

const createSelector = createSelectorCreator(defaultMemoize, isEqual)

const selector = createSelector(state => state, () => console.log("計算された！"))

selector({})
selector({})
```

```
$ node index.js 
計算された！
```

selectorの再計算より、等価チェックなどのメモ化処理の方が重くなってしまうと本末転倒なので気をつける。



# 10月12日

## Prisma
https://www.prisma.io/docs/guides/database/seed-database
Prismaのseed機能を触ってみた。  
prisma/seed.tsに定義しデータベースの初期データを流し込むことができる。

package.jsonに↓を追記
```json
"prisma": {
  "seed": "ts-node prisma/seed.ts"
},
```
Next.jsを使ってる時は↓
```json
"prisma": {
   "seed": "ts-node --compiler-options {\"module\":\"CommonJS\"} prisma/seed.ts"
},
```

prisma/seed.ts
```typescript
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient()

async function main() {
  const alice = await prisma.user.upsert({
    where: { email: 'alice@prisma.io' },
    update: {},
    create: {
      email: 'alice@prisma.io',
      name: 'Alice',
    },
  })
}

main()
  .catch((e) => {
    console.error(e)
    process.exit(1)
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

seedを流し込みタイミング
* `prisma migrate reset` or `prisma migrate dev` コマンドを実行した時。 (seedのスキップは--skip-seed)
* 手動で `prisma db seed` を実行した時

## reselect 
https://github.com/reduxjs/reselect  
オブジェクトを返すselectorを別のselectorに渡してもメモ化できるのか検証。  
=> 結論、できる。

index.js
```js
const reselect = require('reselect')

const a = state => state.a
const b = state => state.b

const selector = reselect.createSelector(
  a,
  b,
  (a, b) => {
    console.log('selector')
    return {...a, ...b}
  }
)

const selector2 = reselect.createSelector(selector, a, (selector, a) => {
  console.log('selector2')
  return {...selector, ...a}
})

const selector3 = reselect.createSelector(selector, selector2, (selector, selector2) => {
  console.log('selector3')
  return {...selector, ...selector2}
})

let state = {
  a: {},
  b: {},
  c: {}
}

selector3(state)

selector3({...state, c: {}})
```

2回目のselector3呼出では、各selectorの関数は実行されていない。
```bash
$ node index.js
selector
selector2
selector3
```








# 10月10日

## Prisma

## ドキュメントリーディング
https://www.prisma.io/docs/concepts

### What is Prisma?

PrismaとはObject-relational mapping(ORM)。  
3つにされる構成される。
* Prisma Client: Node.jsとTypeScript用の自動生成されたタイプセーフなクエリビルダー
* Prisma Migrate: Migration system
* Prisma Studio: GUIでデータベースを操作できる

Prisma Clientは、Node.jsとTypescriptのバックエンドアプリケーションに使用する(サーバーレスアプリケーションやマイクロサービスも含む)。  
REST API、GraphQL API、gRPC APIどれでも対応可能。

### How does Prisma work?
Prismaスキーマファイルで、アプリケーションモデルを定義したり、DBコネクションやジェネレターを定義する。  
Prismaスキーマファイルは以下の3つで構成される
* Data source: DB接続を指定
* Generator: Prismaクライアントを生成
* Data model: アプリケーションモデルを定義

#### Prismaデータモデル

データモデルはモデルのコレクションであり、2つの主要な機能がある。
* リレーショナルデータベースのテーブルまたはMongoDBのコレクションを表す
* Prisma ClientAPIでクエリの基盤を提供する

Prismaスキーマにデータモデルを取得するための2つの方法
* Prisma Migrateを使用して、手動でデータモデルを記述して、データベースにマッピングする
* データベースからの内省



